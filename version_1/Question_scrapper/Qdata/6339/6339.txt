There is a rooted binary tree with
N nodes. For each node with exactly two children, one of them is called the left child and the other is called the right child. If a node has only one child, it is still specifically called either the left child or the right child.
The nodes are labelled
1 through
N according to the inorder traversal of the tree. That is, the labelling can be generated by the following pseudocode:
integer index = 1

function dfs(node n):
    if n has left_child:
        dfs(n.left_child)
    n.label = index
    index += 1
    if n has right_child:
        dfs(n.right_child)

run dfs(root)
For each node
x, the subtree of this node consists of the node
x itself and all its (direct or indirect) descendants. Since the nodes are labelled according to inorder traversal, the subtree of node
x can be described by two integers
a
x
and
b
x
in the following way: the nodes
a
x
,a
x
+1,…,b
x
all belong to the subtree of node
x and all other nodes do not belong to this subtree.
You do not know the structure of the tree. You would like to reconstruct it by asking questions in the form: "Is
a
x
equal to
a and also
b
x
equal to
b?" You may ask at most
300 such questions. Find the root and the parent of each non-root node.
Interaction
First, you should read a line containing a single integer
T — the number of test cases. The description of interaction for
T test cases follows.
For each test case, you should start by reading a line containing a single integer
N.
Afterwards, you may ask questions. To ask a question, print a line containing the character 'Q' followed by a space and three space-separated integers
x,
a and
b (
1≤x≤N,
1≤a≤x≤b≤N). Then, you should read a line containing the string "Yes" if
a is equal to
a
x
and
b is equal to
b
x
or "No" otherwise.
When you are ready to answer, print a line containing the character 'A' followed by a space and
N space-separated integers
p
1
,p
2
,…,p
N
. For each valid
i,
p
i
should denote the parent of the
i-th node or, if the
i-th node is the root, it should be
−1. Your answer will be considered correct if it exactly describes the hidden tree.
Don't forget to flush the output after printing each line!
Constraints
1≤T≤100
Subtasks
Subtask #1 (20 points):
1≤N≤10
Subtask #2 (20 points):
1≤N≤20
Subtask #3 (30 points):
1≤N≤50
Subtask #4 (30 points):
1≤N≤100
Example Input
Grader  | You
2       |
2       |
        | Q 1 1 2
No      |
        | A 2 -1
5       |
        | Q 4 1 5
Yes     |
        | Q 1 1 4
No      |
        | Q 3 1 3
Yes     |
        | Q 1 1 2
Yes     |
        | A 3 1 4 -1 4
Explanation
Example case 1: The tree has only two nodes — node
2 is the root and node
1 is its left child. In this case, we have
a
1
=1,
b
1
=1,
a
2
=1 and
b
2
=2. First, we ask if the subtree of node
1 subtree contains the nodes
1 and
2. The answer is "No", so we know that node
2 is the root and node
1 is its child, which is what we needed to find out.
Example case 2: In the first question, we ask if nodes
1 through
5 are all in the subtree of node
4. In this case, the answer is "Yes", so we know that node
4 is the root of the whole tree. We still need to ask more questions to determine how nodes
1,
2,
3 and
5 are connected to it.