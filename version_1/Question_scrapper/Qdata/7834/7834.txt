This is the easy version of the problem. It differs from the hard one only in constraints on
ğ‘›
. You can make hacks only if you lock both versions.
Let
ğ‘
1
,
ğ‘
2
,â€¦,
ğ‘
ğ‘›
be an array of non-negative integers. Let
ğ¹(
ğ‘
1
,
ğ‘
2
,â€¦,
ğ‘
ğ‘›
)
be the sorted in the non-decreasing order array of
ğ‘›âˆ’1
smallest numbers of the form
ğ‘
ğ‘–
+
ğ‘
ğ‘—
, where
1â‰¤ğ‘–<ğ‘—â‰¤ğ‘›
. In other words,
ğ¹(
ğ‘
1
,
ğ‘
2
,â€¦,
ğ‘
ğ‘›
)
is the sorted in the non-decreasing order array of
ğ‘›âˆ’1
smallest sums of all possible pairs of elements of the array
ğ‘
1
,
ğ‘
2
,â€¦,
ğ‘
ğ‘›
. For example,
ğ¹(1,2,5,7)=[1+2,1+5,2+5]=[3,6,7]
.
You are given an array of non-negative integers
ğ‘
1
,
ğ‘
2
,â€¦,
ğ‘
ğ‘›
. Determine the single element of the array
ğ¹(ğ¹(ğ¹â€¦ğ¹
î„½
î„¾
î…
î…‹
î…‹
î…‹
î…‹
ğ‘›âˆ’1
(
ğ‘
1
,
ğ‘
2
,â€¦,
ğ‘
ğ‘›
)â€¦))
. Since the answer can be quite large, output it modulo
10
9
+7
.
Input
The first line contains one integer
ğ‘›
(
2â‰¤ğ‘›â‰¤3000
) â€” the initial length of the array.
The second line contains
ğ‘›
integers
ğ‘
1
,
ğ‘
2
,â€¦,
ğ‘
ğ‘›
(
0â‰¤
ğ‘
ğ‘–
â‰¤
10
9
) â€” the array elements.
Output
Output a single number â€” the answer modulo
10
9
+7
.
Examples
input
Copy
5
1 2 4 5 6
output
Copy
34
input
Copy
9
1 1 1 7 7 7 9 9 9
output
Copy
256
input
Copy
7
1 7 9 2 0 0 9
output
Copy
20
input
Copy
3
1000000000 1000000000 777
output
Copy
1540
Note
In the first test, the array is transformed as follows:
[1,2,4,5,6]â†’[3,5,6,6]â†’[8,9,9]â†’[17,17]â†’[34]
. The only element of the final array is
34
.
In the second test,
ğ¹(
ğ‘
1
,
ğ‘
2
,â€¦,
ğ‘
ğ‘›
)
is
[2,2,2,8,8,8,8,8]
. This array is made up of
3
numbers of the form
1+1
and
5
numbers of the form
1+7
.
In the fourth test, the array is transformed as follows:
[
10
9
,
10
9
,777]â†’[
10
9
+777,
10
9
+777]â†’[2â‹…
10
9
+1554]
.
2â‹…
10
9
+1554
modulo
10
9
+7
equals
1540
.