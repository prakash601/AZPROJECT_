Jack has a graph of
ğ‘›
vertices and
ğ‘š
edges. All edges are bidirectional and of unit length. The graph is connected, i. e. there exists a path between any two of its vertices. There can be more than one edge connecting the same pair of vertices. The graph can contain self-loops, i. e. edges connecting a node to itself.
The distance between vertices
ğ‘¢
and
ğ‘£
is denoted as
ğœŒ(ğ‘¢,ğ‘£)
and equals the minimum possible number of edges on a path between
ğ‘¢
and
ğ‘£
. The diameter of graph
ğº
is defined as the maximum possible distance between some pair of its vertices. We denote it as
ğ‘‘(ğº)
. In other words,
ğ‘‘(ğº)=
max
1â‰¤ğ‘¢,ğ‘£â‰¤ğ‘›
ğœŒ(ğ‘¢,ğ‘£).
d
(
G
)
(
)
Jack plans to consecutively apply
ğ‘
updates to his graph. Each update adds exactly one edge to the graph. Denote as
ğº
ğ‘–
the graph after exactly
ğ‘–
updates are made. Jack wants to calculate
ğ‘+1
values
ğ‘‘(
ğº
0
),ğ‘‘(
ğº
1
),ğ‘‘(
ğº
2
),â€¦,ğ‘‘(
ğº
ğ‘
)
.
However, Jack suspects that finding the exact diameters of
ğ‘+1
graphs might be a difficult task, so he is fine with approximate answers that differ from the correct answers no more than twice. Formally, Jack wants to find a sequence of positive integers
ğ‘
0
,
ğ‘
1
,
ğ‘
2
,â€¦,
ğ‘
ğ‘
such that
âŒˆ
ğ‘‘(
ğº
ğ‘–
)
2
âŒ‰â‰¤
ğ‘
ğ‘–
â‰¤2â‹…ğ‘‘(
ğº
ğ‘–
)
âŒˆ
(
)
âŒ‰
for each
ğ‘–
.
Hacks
You cannot make hacks in this problem.
Input
The first line of the input contains three integers
ğ‘›
,
ğ‘š
, and
ğ‘
(
2â‰¤ğ‘›â‰¤
10
5
,
ğ‘›âˆ’1â‰¤ğ‘šâ‰¤
10
5
,
0â‰¤ğ‘â‰¤
10
5
), the number of vertices in the given graph, the number of edges and the number of updates, respectively.
Then follow
ğ‘š
lines describing the initial edges of the graph. The
ğ‘–
-th of these lines contains two integers
ğ‘¢
ğ‘–
and
ğ‘£
ğ‘–
(
1â‰¤
ğ‘¢
ğ‘–
,
ğ‘£
ğ‘–
â‰¤ğ‘›
), the indexes of the vertices connected by the
ğ‘–
-th edge.
Then follow
ğ‘
lines describing the updates. The
ğ‘–
-th of these lines contains two integers
ğ‘¢
â€²
ğ‘–
and
ğ‘£
â€²
ğ‘–
(
1â‰¤
ğ‘¢
â€²
ğ‘–
,
ğ‘£
â€²
ğ‘–
â‰¤ğ‘›
), the indexes of the vertices connected by the edge that is added to the graph in the
ğ‘–
-th update.
Important note. For testing purposes, the input data may contain some extra lines after the mentioned input format. These will be used by the checker to verify your answer. They are not a part of the test data, you should not use them in any way and you can even omit reading them.
Output
Print a sequence of
ğ‘+1
positive integers
ğ‘
0
,
ğ‘
1
,
ğ‘
2
,â€¦,
ğ‘
ğ‘
. The
ğ‘–
-th of these integers should differ from the diameter of graph
ğº
ğ‘–
no more than twice.
Examples
input
Copy
9 10 8
1 2
2 3
2 4
3 5
4 5
5 6
5 7
6 8
7 8
8 9
3 4
6 7
2 8
1 9
1 6
4 9
3 9
7 1
output
Copy
10 6 5 6 2 4 2 2 1
input
Copy
8 7 9
1 2
2 3
3 4
4 5
5 6
6 7
7 8
1 5
3 7
2 4
4 6
6 8
8 2
5 4
2 4
3 3
1 652997 124613 653029 653029 124613 124613 124613 648901 124613 653029
output
Copy
7 5 4 4 4 3 3 3 3 3
Note
In the first example, the correct sequence of
ğ‘‘(
ğº
0
),ğ‘‘(
ğº
1
),ğ‘‘(
ğº
2
),â€¦,ğ‘‘(
ğº
ğ‘
)
is
6,6,6,3,3,3,2,2,2
.
In the second example, the input contains an extra line that you can omit reading. It is not a part of the test and will be used for verifying your answer. The output of the second example contains the correct values of
ğ‘‘(
ğº
ğ‘–
)
.