Hossam makes a big party, and he will invite his friends to the party.
He has
ğ‘›
friends numbered from
1
to
ğ‘›
. They will be arranged in a queue as follows:
1,2,3,â€¦,ğ‘›
.
Hossam has a list of
ğ‘š
pairs of his friends that don't know each other. Any pair not present in this list are friends.
A subsegment of the queue starting from the friend
ğ‘
and ending at the friend
ğ‘
is
[ğ‘,ğ‘+1,ğ‘+2,â€¦,ğ‘]
. A subsegment of the queue is called good when all pairs of that segment are friends.
Hossam wants to know how many pairs
(ğ‘,ğ‘)
there are (
1â‰¤ğ‘â‰¤ğ‘â‰¤ğ‘›
), such that the subsegment starting from the friend
ğ‘
and ending at the friend
ğ‘
is good.
Input
The input consists of multiple test cases. The first line contains a single integer
ğ‘¡
(
1â‰¤ğ‘¡â‰¤2â‹…
10
4
), the number of test cases. Description of the test cases follows.
The first line of each test case contains two integer numbers
ğ‘›
and
ğ‘š
(
2â‰¤ğ‘›â‰¤
10
5
,
0â‰¤ğ‘šâ‰¤
10
5
) representing the number of friends and the number of pairs, respectively.
The
ğ‘–
-th of the next
ğ‘š
lines contains two integers
ğ‘¥
ğ‘–
and
ğ‘¦
ğ‘–
(
1â‰¤
ğ‘¥
ğ‘–
,
ğ‘¦
ğ‘–
â‰¤ğ‘›
,
ğ‘¥
ğ‘–
â‰ 
ğ‘¦
ğ‘–
) representing a pair of Hossam's friends that don't know each other.
Note that pairs can be repeated.
It is guaranteed that the sum of
ğ‘›
over all test cases does not exceed
10
5
, and the sum of
ğ‘š
over all test cases does not exceed
10
5
.
Output
For each test case print an integer â€” the number of good subsegments.
Example
input
Copy
2
3 2
1 3
2 3
4 2
1 2
2 3
output
Copy
4
5
Note
In the first example, the answer is
4
.
The good subsegments are:
[1]
[2]
[3]
[1, 2]
In the second example, the answer is
5
.
The good subsegments are:
[1]
[2]
[3]
[4]
[3, 4]